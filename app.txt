#app
import tkinter as tk
from tkinter import ttk
from gui import GuiManager
from operations import (
    add_sale_window,
    add_buyout_window
)
from reports import generate_sales_report, generate_buyouts_report, generate_custom_report

class AutoSalonApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Автосалон — Управление БД")
        self.gui = GuiManager(root, self)

        btn_frame = ttk.Frame(root)
        btn_frame.pack(pady=10)

        ttk.Button(btn_frame, text="Добавить продажу", command=lambda: add_sale_window(self)).pack(side="left", padx=5)
        ttk.Button(btn_frame, text="Добавить выкуп", command=lambda: add_buyout_window(self)).pack(side="left", padx=5)
        ttk.Button(btn_frame, text="Обновить данные", command=self.gui.refresh_all_tables).pack(side="left", padx=5)
        ttk.Button(btn_frame, text="Отчет по продажам", command=lambda: generate_sales_report(self)).pack(side="left", padx=5)
        ttk.Button(btn_frame, text="Отчет по выкупам", command=lambda: generate_buyouts_report(self)).pack(side="left", padx=5)
        ttk.Button(btn_frame, text="Настраиваемый отчет", command=lambda: generate_custom_report(self)).pack(side="left", padx=5)

if __name__ == "__main__":
    root = tk.Tk()
    app = AutoSalonApp(root)
    root.geometry("800x600")
    root.mainloop()
	
#config
DB_NAME = "автосалон.db"

# Справочники
BUYERS = ["Татосян А.", "Серебреников Г.", "Халимов Р.", "Алиев А."]
CAR_CONDITIONS = ["(A) Отличное", "(B) Хорошее", "(C) Среднее", "(D) Плохое"]
SELLERS = ["Заргарян А.", "Язовских С.", "Кириллов А.", "Туник Д."]

#database
import sqlite3
from config import DB_NAME

def get_table_columns(table_name):
    conn = sqlite3.connect(DB_NAME)
    cur = conn.cursor()
    cur.execute(f"PRAGMA table_info({table_name})")
    columns = [info[1] for info in cur.fetchall()]
    conn.close()
    return columns

def load_table_data(table_name):
    conn = sqlite3.connect(DB_NAME)
    cur = conn.cursor()
    cur.execute(f"SELECT * FROM {table_name}")
    rows = cur.fetchall()
    conn.close()
    return rows

def execute_query(query, params=None):
    conn = sqlite3.connect(DB_NAME)
    cur = conn.cursor()
    if params:
        cur.execute(query, params)
    else:
        cur.execute(query)
    conn.commit()
    conn.close()

def fetch_one(query, params=None):
    conn = sqlite3.connect(DB_NAME)
    cur = conn.cursor()
    if params:
        cur.execute(query, params)
    else:
        cur.execute(query)
    result = cur.fetchone()
    conn.close()
    return result

def fetch_all(query, params=None):
    conn = sqlite3.connect(DB_NAME)
    cur = conn.cursor()
    if params:
        cur.execute(query, params)
    else:
        cur.execute(query)
    result = cur.fetchall()
    conn.close()
    return result
	
import tkinter as tk
from tkinter import ttk, Toplevel
from database import get_table_columns, fetch_all, load_table_data


class GuiManager:
    def __init__(self, root, app):
        self.root = root
        self.app = app
        self.notebook = ttk.Notebook(root)
        self.notebook.pack(fill="both", expand=True, padx=10, pady=10)

        # Хранит состояние сортировки: {столбец: 'asc'/'desc'}
        self.sort_states = {}

        self.create_tab("Автомобили")
        self.create_tab("Клиенты")
        self.create_tab("Продажи")
        self.create_tab("Выкуп")

    def create_tab(self, table_name):
        frame = ttk.Frame(self.notebook)
        self.notebook.add(frame, text=table_name)

        tree = ttk.Treeview(frame, show="headings")
        tree.pack(side="left", fill="both", expand=True)

        scrollbar = ttk.Scrollbar(frame, orient="vertical", command=tree.yview)
        scrollbar.pack(side="right", fill="y")
        tree.configure(yscrollcommand=scrollbar.set)

        columns = get_table_columns(table_name)
        display_columns = [col for col in columns if not col.startswith("ID_")]
        tree["columns"] = display_columns

        for col in display_columns:
            tree.heading(col, text=col, command=lambda c=col: self.sort_column(tree, table_name, c))
            tree.column(col, width=120 if col in ["ФИО", "VIN"] else 100)

        setattr(self.app, f"tree_{table_name}", tree)
        self.load_table(tree, table_name)

    def refresh_all_tables(self):
        for table in ["Автомобили", "Клиенты", "Продажи", "Выкуп"]:
            tree = getattr(self.app, f"tree_{table}", None)
            if tree:
                self.load_table(tree, table)

    def sort_column(self, tree, table_name, column):
        current_state = self.sort_states.get(column, None)

        if current_state == "asc":
            direction = "desc"
            arrow = " ↓"
        else:
            direction = "asc"
            arrow = " ↑"

        # Убираем все стрелочки
        for col in tree["columns"]:
            tree.heading(col, text=col.split(" ")[0])

        # Добавляем новую
        tree.heading(column, text=f"{column}{arrow}")

        # Обновляем состояние
        self.sort_states.clear()
        self.sort_states[column] = direction

        # Перезагружаем таблицу с сортировкой
        self.load_table(tree, table_name, sort_by=column, sort_order=direction)

    def load_table(self, tree, table_name, sort_by=None, sort_order="asc"):
        # Очистка таблицы
        for row in tree.get_children():
            tree.delete(row)

        all_columns = get_table_columns(table_name)
        display_columns = [col for col in all_columns if not col.startswith("ID_")]

        if table_name == "Автомобили":
            query = """
                SELECT 
                    VIN,
                    Марка,
                    Модель,
                    Пробег,
                    Год_выпуска,
                    Цена,
                    Состояние,
                    Статус_склада
                FROM Автомобили
            """

            order_col_map = {
                "VIN": "VIN",
                "Марка": "Марка",
                "Модель": "Модель",
                "Пробег": "CAST(Пробег AS INTEGER)",
                "Год_выпуска": "CAST(Год_выпуска AS INTEGER)",
                "Цена": "CAST(Цена AS REAL)",
                "Состояние": "Состояние",
                "Статус_склада": "Статус_склада"
            }

            if sort_by and sort_by in order_col_map:
                query += f" ORDER BY {order_col_map[sort_by]} {sort_order.upper()}"

            rows = fetch_all(query)

            columns = ["VIN", "Марка", "Модель", "Пробег", "Год_выпуска", "Цена", "Состояние", "Статус_склада"]
            tree["columns"] = columns

            for col in columns:
                tree.heading(col, text=col, command=lambda c=col: self.sort_column(tree, table_name, c))
                tree.column(col, width=120 if col in ["VIN"] else 100)

            for row in rows:
                display_row = [
                    row[0],  # VIN
                    row[1],  # Марка
                    row[2],  # Модель
                    row[3],  # Пробег
                    row[4],  # Год выпуска
                    f"{row[5]:.2f}" if row[5] is not None else "",  # Цена
                    row[6],  # Состояние
                    row[7],  # Статус склада
                ]
                tree.insert("", "end", values=display_row)

        elif table_name == "Клиенты":
            query = """
                SELECT 
                    ФИО,
                    Телефон,
                    Адрес
                FROM Клиенты
            """

            order_col_map = {
                "ФИО": "ФИО",
                "Телефон": "Телефон",
                "Адрес": "Адрес"
            }

            if sort_by and sort_by in order_col_map:
                query += f" ORDER BY {order_col_map[sort_by]} {sort_order.upper()}"

            rows = fetch_all(query)

            columns = ["ФИО", "Телефон", "Адрес"]
            tree["columns"] = columns

            for col in columns:
                tree.heading(col, text=col, command=lambda c=col: self.sort_column(tree, table_name, c))
                tree.column(col, width=120 if col == "ФИО" else 100)

            for row in rows:
                display_row = [
                    row[0],  # ФИО
                    row[1],  # Телефон
                    row[2],  # Адрес
                ]
                tree.insert("", "end", values=display_row)

        elif table_name == "Продажи":
            query = """
                SELECT 
                    Продажи.ID_Продажи,
                    Автомобили.VIN,
                    Клиенты.ФИО,
                    Продажи.Дата_Продажи,
                    Продажи.Сумма,
                    Выкуп.Сумма_Выкупа,
                    (Продажи.Сумма - IFNULL(Выкуп.Сумма_Выкупа, 0)) AS Прибыль,
                    Продавец
                FROM Продажи
                JOIN Автомобили ON Продажи.ID_Автомобиля = Автомобили.ID_Автомобиля
                JOIN Клиенты ON Продажи.ID_Клиента = Клиенты.ID_Клиента
                LEFT JOIN Выкуп ON Автомобили.ID_Автомобиля = Выкуп.ID_Автомобиля
            """

            order_col_map = {
                "VIN": "Автомобили.VIN",
                "ФИО": "Клиенты.ФИО",
                "Дата продажи": "Продажи.Дата_Продажи",
                "Сумма": "CAST(Продажи.Сумма AS REAL)",
                "Сумма выкупа": "CAST(IFNULL(Выкуп.Сумма_Выкупа, 0) AS REAL)",
                "Прибыль": "CAST((Продажи.Сумма - IFNULL(Выкуп.Сумма_Выкупа, 0)) AS REAL)",
                "Продавец": "Продавец"
            }

            if sort_by and sort_by in order_col_map:
                query += f" ORDER BY {order_col_map[sort_by]} {sort_order.upper()}"

            rows = fetch_all(query)

            columns = ["VIN", "ФИО", "Дата продажи", "Сумма", "Сумма выкупа", "Прибыль", "Продавец"]
            tree["columns"] = columns

            for col in columns:
                tree.heading(col, text=col, command=lambda c=col: self.sort_column(tree, table_name, c))
                tree.column(col, width=120 if col in ["ФИО", "VIN"] else 100)

            for row in rows:
                display_row = [
                    row[1],  # VIN
                    row[2],  # ФИО
                    row[3],  # Дата продажи
                    f"{row[4]:.2f}" if row[4] is not None else "",  # Сумма
                    f"{row[5]:.2f}" if row[5] is not None else "0.00",  # Сумма выкупа
                    f"{row[6]:.2f}" if row[6] is not None else "0.00",  # Прибыль
                    row[7],  # Продавец
                ]
                tree.insert("", "end", values=display_row)

        elif table_name == "Выкуп":
            query = """
                SELECT 
                    Выкуп.Дата_Выкупа,
                    Выкуп.Сумма_Выкупа,
                    Выкуп.Выкупщик,
                    Автомобили.VIN,
                    Клиенты.ФИО
                FROM Выкуп
                JOIN Автомобили ON Выкуп.ID_Автомобиля = Автомобили.ID_Автомобиля
                JOIN Клиенты ON Выкуп.ID_Клиента = Клиенты.ID_Клиента
            """

            order_col_map = {
                "Дата выкупа": "Выкуп.Дата_Выкупа",
                "Сумма выкупа": "CAST(Выкуп.Сумма_Выкупа AS REAL)",
                "Выкупщик": "Выкуп.Выкупщик",
                "VIN": "Автомобили.VIN",
                "ФИО": "Клиенты.ФИО"
            }

            if sort_by and sort_by in order_col_map:
                query += f" ORDER BY {order_col_map[sort_by]} {sort_order.upper()}"

            rows = fetch_all(query)

            columns = ["Дата выкупа", "Сумма выкупа", "Выкупщик", "VIN", "ФИО"]
            tree["columns"] = columns

            for col in columns:
                tree.heading(col, text=col, command=lambda c=col: self.sort_column(tree, table_name, c))
                tree.column(col, width=120 if col in ["Дата выкупа", "VIN", "ФИО"] else 100)

            for row in rows:
                display_row = [
                    row[0],  # Дата выкупа
                    f"{row[1]:.2f}" if row[1] is not None else "0.00",  # Сумма выкупа
                    row[2],  # Выкупщик
                    row[3],  # VIN
                    row[4],  # ФИО клиента
                ]
                tree.insert("", "end", values=display_row)
				
#operations
import tkinter as tk
from tkinter import ttk, Toplevel, messagebox
from tkcalendar import DateEntry
from datetime import datetime
from database import execute_query, fetch_one, fetch_all
from config import SELLERS, BUYERS

def add_sale_window(app):
    window = Toplevel(app.root)
    window.title("Добавить продажу")
    window.geometry("400x350")

    fields = {
        "VIN": "VIN автомобиля (17 символов)",
        "ФИО": "ФИО клиента",
        "Телефон": "Номер телефона (11 цифр)",
        "Адрес": "Адрес клиента",
        "Дата_Продажи": "Дата продажи (YYYY-MM-DD)",
        "Сумма": "Сумма продажи",
        "Продавец": "Продавец"
    }

    entries = {}

    for key, label in fields.items():
        row = ttk.Frame(window)
        row.pack(fill="x", pady=5)

        ttk.Label(row, text=label, width=25).pack(side="left")

        if key == "Дата_Продажи":
            date_entry = DateEntry(row, date_pattern='yyyy-mm-dd')
            date_entry.pack(side="right", fill="x", expand=True, padx=5)
            entries[key] = date_entry
        elif key == "Продавец":
            combo = ttk.Combobox(row, values=SELLERS)
            combo.pack(side="right", fill="x", expand=True, padx=5)
            entries[key] = combo
        else:
            entry = ttk.Entry(row)
            entry.pack(side="right", fill="x", expand=True, padx=5)
            entries[key] = entry

    ttk.Button(
        window,
        text="Добавить",
        command=lambda: save_sale(entries, window, app)
    ).pack(pady=10)

def save_sale(entries, window, app):
    vin = entries["VIN"].get().strip()
    client_data = {
        "ФИО": entries["ФИО"].get(),
        "Телефон": entries["Телефон"].get(),
        "Адрес": entries["Адрес"].get()
    }
    sale_data = {
        "Дата_Продажи": entries["Дата_Продажи"].get(),
        "Сумма": entries["Сумма"].get(),
        "Продавец": entries["Продавец"].get()
    }

    if len(vin) != 17:
        messagebox.showerror("Ошибка", "VIN должен содержать 17 символов.")
        return
    if not client_data["Телефон"].isdigit() or len(client_data["Телефон"]) != 11:
        messagebox.showerror("Ошибка", "Телефон должен состоять из 11 цифр.")
        return

    try:
        car_id_row = fetch_one("SELECT ID_Автомобиля FROM Автомобили WHERE VIN=?", (vin,))
        if not car_id_row:
            messagebox.showerror("Ошибка", "Автомобиль с таким VIN не найден.")
            return
        car_id = car_id_row[0]

        query_client = "INSERT INTO Клиенты (ФИО, Телефон, Адрес) VALUES (?, ?, ?)"
        execute_query(query_client, (client_data["ФИО"], client_data["Телефон"], client_data["Адрес"]))
        client_id = fetch_one("SELECT last_insert_rowid()")[0]

        query_sale = """
            INSERT INTO Продажи (ID_Автомобиля, ID_Клиента, Дата_Продажи, Сумма, Продавец)
            VALUES (?, ?, ?, ?, ?)
        """
        execute_query(query_sale, (
            car_id,
            client_id,
            sale_data["Дата_Продажи"],
            float(sale_data["Сумма"]),
            sale_data["Продавец"]
        ))

        execute_query("UPDATE Автомобили SET Статус_склада = 'Продан' WHERE ID_Автомобиля = ?", (car_id,))

        app.gui.refresh_all_tables()
        messagebox.showinfo("Успех", "Продажа успешно добавлена!")
        window.destroy()

    except Exception as e:
        messagebox.showerror("Ошибка", str(e))

def add_buyout_window(app):
    window = Toplevel(app.root)
    window.title("Добавить выкуп")
    window.geometry("400x600")

    fields = {
        "VIN": "VIN автомобиля (17 символов)",
        "Марка": "Марка автомобиля",
        "Модель": "Модель автомобиля",
        "Пробег": "Пробег в км (до 999 999)",
        "Год_выпуска": "Год выпуска (1900 - текущий год)",
        "Цена_для_публикации": "Цена для публикации",
        "Состояние": "Состояние авто",
        "Дата_Выкупа": "Дата выкупа",
        "Сумма_Выкупа": "Сумма выкупа",
        "Выкупщик": "Выкупщик",
        "ФИО": "ФИО клиента",
        "Телефон": "Номер телефона (11 цифр)",
        "Адрес": "Адрес клиента"
    }

    entries = {}

    for key, label in fields.items():
        row = ttk.Frame(window)
        row.pack(fill="x", pady=5)
        ttk.Label(row, text=label, width=25).pack(side="left")

        if key == "Состояние":
            combo = ttk.Combobox(row, values=["(A) Отличное", "(B) Хорошее", "(C) Среднее", "(D) Плохое"])
            combo.pack(side="right", fill="x", expand=True, padx=5)
            entries[key] = combo
        elif key == "Дата_Выкупа":
            date_entry = DateEntry(row, date_pattern='yyyy-mm-dd')
            date_entry.pack(side="right", fill="x", expand=True, padx=5)
            entries[key] = date_entry
        elif key == "Выкупщик":
            combo = ttk.Combobox(row, values=BUYERS)
            combo.pack(side="right", fill="x", expand=True, padx=5)
            entries[key] = combo
        else:
            entry = ttk.Entry(row)
            entry.pack(side="right", fill="x", expand=True, padx=5)
            entries[key] = entry

    ttk.Button(
        window,
        text="Добавить",
        command=lambda: save_buyout(entries, window, app)
    ).pack(pady=10)

def save_buyout(entries, window, app):
    vin = entries["VIN"].get().strip()
    car_data = {
        "Марка": entries["Марка"].get(),
        "Модель": entries["Модель"].get(),
        "Пробег": entries["Пробег"].get(),
        "Год_выпуска": entries["Год_выпуска"].get(),
        "Цена_для_публикации": entries["Цена_для_публикации"].get(),
        "Состояние": entries["Состояние"].get()[1]
    }
    client_data = {
        "ФИО": entries["ФИО"].get(),
        "Телефон": entries["Телефон"].get(),
        "Адрес": entries["Адрес"].get()
    }
    buyout_data = {
        "Дата_Выкупа": entries["Дата_Выкупа"].get(),
        "Сумма_Выкупа": entries["Сумма_Выкупа"].get(),
        "Выкупщик": entries["Выкупщик"].get()
    }

    if len(vin) != 17:
        messagebox.showerror("Ошибка", "VIN должен содержать 17 символов.")
        return
    if not car_data["Пробег"].isdigit() or not 0 <= int(car_data["Пробег"]) <= 999999:
        messagebox.showerror("Ошибка", "Пробег должен быть числом от 0 до 999 999.")
        return

    year = car_data["Год_выпуска"]
    current_year = datetime.now().year
    if not year.isdigit() or not 1900 <= int(year) <= current_year:
        messagebox.showerror("Ошибка", f"Год выпуска должен быть от 1900 до {current_year}.")
        return

    try:
        price_pub = float(car_data["Цена_для_публикации"])
        buyout_sum = float(buyout_data["Сумма_Выкупа"])
        if price_pub < buyout_sum:
            messagebox.showerror("Ошибка", "Цена должна быть не меньше суммы выкупа.")
            return
    except ValueError:
        messagebox.showerror("Ошибка", "Цена или сумма указаны неверно.")
        return

    if not client_data["Телефон"].isdigit() or len(client_data["Телефон"]) != 11:
        messagebox.showerror("Ошибка", "Телефон должен состоять из 11 цифр.")
        return

    try:
        query_car = """
            INSERT INTO Автомобили (VIN, Марка, Модель, Пробег, Год_выпуска, Цена, Состояние, Статус_склада)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        """
        execute_query(query_car, (
            vin,
            car_data["Марка"],
            car_data["Модель"],
            int(car_data["Пробег"]),
            int(car_data["Год_выпуска"]),
            float(car_data["Цена_для_публикации"]),
            car_data["Состояние"],
            "На складе"
        ))
        car_id = fetch_one("SELECT last_insert_rowid()")[0]

        query_client = "INSERT INTO Клиенты (ФИО, Телефон, Адрес) VALUES (?, ?, ?)"
        execute_query(query_client, (
            client_data["ФИО"],
            client_data["Телефон"],
            client_data["Адрес"]
        ))
        client_id = fetch_one("SELECT last_insert_rowid()")[0]

        query_buyout = """
            INSERT INTO Выкуп (ID_Автомобиля, ID_Клиента, Дата_Выкупа, Сумма_Выкупа, Выкупщик)
            VALUES (?, ?, ?, ?, ?)
        """
        execute_query(query_buyout, (
            car_id,
            client_id,
            buyout_data["Дата_Выкупа"],
            float(buyout_data["Сумма_Выкупа"]),
            buyout_data["Выкупщик"]
        ))

        app.gui.refresh_all_tables()
        messagebox.showinfo("Успех", "Выкуп успешно добавлен!")
        window.destroy()

    except Exception as e:
        messagebox.showerror("Ошибка", str(e))
		
#reports
import tkinter as tk
from tkinter import ttk, Toplevel, messagebox
from database import fetch_all
from config import BUYERS
from tkcalendar import DateEntry


def generate_sales_report(app):
    def show_report(start_cal, end_cal, buyer_combo, seller_combo):
        start_date = start_cal.get()
        end_date = end_cal.get()
        selected_buyer = buyer_combo.get() if buyer_combo else None
        selected_seller = seller_combo.get() if seller_combo else None

        query = """
            SELECT 
                Автомобили.VIN,
                Продажи.Дата_Продажи,
                Клиенты.ФИО,
                Выкуп.Выкупщик,
                Продавец,
                (Продажи.Сумма - IFNULL(Выкуп.Сумма_Выкупа, 0)) AS Прибыль
            FROM Продажи
            JOIN Автомобили ON Продажи.ID_Автомобиля = Автомобили.ID_Автомобиля
            JOIN Клиенты ON Продажи.ID_Клиента = Клиенты.ID_Клиента
            LEFT JOIN Выкуп ON Автомобили.ID_Автомобиля = Выкуп.ID_Автомобиля
            WHERE Продажи.Дата_Продажи BETWEEN ? AND ?
        """

        params = [start_date, end_date]

        if selected_seller:
            query += " AND Продавец = ?"
            params.append(selected_seller)
        if selected_buyer:
            query += " AND Выкуп.Выкупщик = ?"
            params.append(selected_buyer)

        rows = fetch_all(query, params)

        # Создаем окно отчета
        report_window = Toplevel(app.root)
        report_window.title("Отчет по продажам")
        report_window.geometry("800x600")

        tree = ttk.Treeview(report_window, columns=[
            "VIN", "Дата продажи", "ФИО клиента", "Выкупщик", "Продавец", "Прибыль"
        ], show="headings")

        for col in tree["columns"]:
            tree.heading(col, text=col, command=lambda c=col: sort_column(tree, rows, c, tree["columns"]))
            tree.column(col, width=120)

        tree.pack(fill="both", expand=True)

        total_profit = 0
        for row in rows:
            profit = float(row[5]) if row[5] else 0
            total_profit += profit
            tree.insert("", "end", values=(row[0], row[1], row[2], row[3], row[4], f"{profit:.2f}"))

        footer = ttk.Frame(report_window)
        footer.pack(pady=10)
        ttk.Label(footer, text=f"Общая прибыль: {total_profit:.2f}", font=("Arial", 12, "bold")).pack()

    open_report_window("Отчет по продажам", show_report, with_seller=True, with_buyer=True)


def generate_buyouts_report(app):
    def show_report(start_cal, end_cal, buyer_combo, seller_combo):
        start_date = start_cal.get()
        end_date = end_cal.get()
        selected_buyer = buyer_combo.get() if buyer_combo else None

        query = """
            SELECT 
                Автомобили.VIN,
                Выкуп.Дата_Выкупа,
                Клиенты.ФИО,
                Выкуп.Выкупщик,
                Выкуп.Сумма_Выкупа
            FROM Выкуп
            JOIN Автомобили ON Выкуп.ID_Автомобиля = Автомобили.ID_Автомобиля
            JOIN Клиенты ON Выкуп.ID_Клиента = Клиенты.ID_Клиента
            WHERE Выкуп.Дата_Выкупа BETWEEN ? AND ?
        """
        params = [start_date, end_date]
        if selected_buyer:
            query += " AND Выкуп.Выкупщик = ?"
            params.append(selected_buyer)

        rows = fetch_all(query, params)

        report_window = Toplevel(app.root)
        report_window.title("Отчет по выкупам")
        report_window.geometry("700x500")

        tree = ttk.Treeview(report_window, columns=[
            "VIN", "Дата выкупа", "ФИО клиента", "Выкупщик", "Сумма выкупа"
        ], show="headings")

        for col in tree["columns"]:
            tree.heading(col, text=col, command=lambda c=col: sort_column(tree, rows, c, tree["columns"]))
            tree.column(col, width=140)

        tree.pack(fill="both", expand=True)

        total_sum = 0
        for row in rows:
            amount = float(row[4]) if row[4] else 0
            total_sum += amount
            tree.insert("", "end", values=(row[0], row[1], row[2], row[3], f"{amount:.2f}"))

        footer = ttk.Frame(report_window)
        footer.pack(pady=10)
        ttk.Label(footer, text=f"Общая сумма выкупов: {total_sum:.2f}", font=("Arial", 12, "bold")).pack()

    open_report_window("Отчет по выкупам", show_report, with_seller=False, with_buyer=True)


def generate_custom_report(app):
    CUSTOM_REPORT_COLUMNS = {
        "VIN": "Автомобили.VIN",
        "Марка": "Автомобили.Марка",
        "Модель": "Автомобили.Модель",
        "Пробег": "Автомобили.Пробег",
        "Год выпуска": "Автомобили.Год_выпуска",
        "Цена": "Автомобили.Цена",
        "Состояние": "Автомобили.Состояние",
        "Статус склада": "Автомобили.Статус_склада",
        "Выкупщик": "Выкуп.Выкупщик",
        "Сумма выкупа": "Выкуп.Сумма_Выкупа",
        "ФИО клиента-продавца": "Клиенты.ФИО",
        "Телефон клиента-продавца": "Клиенты.Телефон",
        "Адрес клиента-продавца": "Клиенты.Адрес",
        "ФИО клиента-покупателя": """
            (SELECT КлиентыПокупатель.ФИО FROM Продажи
             JOIN Клиенты AS КлиентыПокупатель ON Продажи.ID_Клиента = КлиентыПокупатель.ID_Клиента
             WHERE Продажи.ID_Автомобиля = Автомобили.ID_Автомобиля)
        """,
        "Телефон клиента-покупателя": """
            (SELECT КлиентыПокупатель.Телефон FROM Продажи
             JOIN Клиенты AS КлиентыПокупатель ON Продажи.ID_Клиента = КлиентыПокупатель.ID_Клиента
             WHERE Продажи.ID_Автомобиля = Автомобили.ID_Автомобиля)
        """,
        "Адрес клиента-покупателя": """
            (SELECT КлиентыПокупатель.Адрес FROM Продажи
             JOIN Клиенты AS КлиентыПокупатель ON Продажи.ID_Клиента = КлиентыПокупатель.ID_Клиента
             WHERE Продажи.ID_Автомобиля = Автомобили.ID_Автомобиля)
        """
    }

    def show_report(start_date, end_date, column_vars):
        nonlocal app
        selected_columns = [col for col, var in column_vars.items() if var.get()]
        if not selected_columns:
            messagebox.showwarning("Ошибка", "Выберите хотя бы один столбец для отчета.")
            return

        columns_sql = ", ".join([CUSTOM_REPORT_COLUMNS[col] for col in selected_columns])

        query = f"""
            SELECT {columns_sql}
            FROM Автомобили
            LEFT JOIN Выкуп ON Автомобили.ID_Автомобиля = Выкуп.ID_Автомобиля
            LEFT JOIN Клиенты ON Выкуп.ID_Клиента = Клиенты.ID_Клиента
            WHERE Выкуп.Дата_Выкупа BETWEEN ? AND ?
        """

        rows = fetch_all(query, [start_date, end_date])

        report_window = Toplevel(app.root)
        report_window.title("Настраиваемый отчет")
        report_window.geometry("1000x600")

        tree = ttk.Treeview(report_window, columns=selected_columns, show="headings")
        for col in selected_columns:
            tree.heading(col, text=col, command=lambda c=col: sort_column(tree, rows, c, selected_columns))
            tree.column(col, width=120)
        tree.pack(fill="both", expand=True)

        for row in rows:
            tree.insert("", "end", values=row)

    def open_column_selection(start_cal, end_cal):
        start_date = start_cal.get()
        end_date = end_cal.get()

        window = Toplevel()
        window.title("Выбор столбцов")
        window.geometry("400x400")

        frame = ttk.Frame(window)
        frame.pack(padx=10, pady=10, fill="both", expand=True)

        canvas = tk.Canvas(frame)
        scroll = ttk.Scrollbar(frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scroll.set)

        canvas.pack(side="left", fill="both", expand=True)
        scroll.pack(side="right", fill="y")

        column_vars = {}
        for col in CUSTOM_REPORT_COLUMNS.keys():
            var = tk.BooleanVar(value=True)
            ttk.Checkbutton(scrollable_frame, text=col, variable=var).pack(anchor="w")
            column_vars[col] = var

        def on_submit():
            window.destroy()
            show_report(start_date, end_date, column_vars)

        ttk.Button(window, text="Сформировать", command=on_submit).pack(pady=10)

    # Окно с выбором дат
    window = Toplevel()
    window.title("Настраиваемый отчет")
    window.geometry("400x300")

    frame = ttk.Frame(window)
    frame.pack(padx=10, pady=10)

    start_cal = DateEntry(frame, date_pattern='yyyy-mm-dd')
    end_cal = DateEntry(frame, date_pattern='yyyy-mm-dd')

    ttk.Label(frame, text="Начальная дата").grid(row=0, column=0, sticky="w")
    start_cal.grid(row=0, column=1, sticky="ew")

    ttk.Label(frame, text="Конечная дата").grid(row=1, column=0, sticky="w")
    end_cal.grid(row=1, column=1, sticky="ew")

    ttk.Button(frame, text="Далее", command=lambda: (
        open_column_selection(start_cal, end_cal),
        window.destroy()
    )).grid(row=5, column=0, columnspan=2, pady=10)

    frame.grid_columnconfigure(1, weight=1)


def open_report_window(title, callback, with_seller=False, with_buyer=False):
    window = Toplevel()
    window.title(title)
    window.geometry("400x300")

    frame = ttk.Frame(window)
    frame.pack(padx=10, pady=10)

    ttk.Label(frame, text="Начальная дата").grid(row=0, column=0, sticky="w")
    start_cal = DateEntry(frame, date_pattern='yyyy-mm-dd')
    start_cal.grid(row=0, column=1, sticky="ew")

    ttk.Label(frame, text="Конечная дата").grid(row=1, column=0, sticky="w")
    end_cal = DateEntry(frame, date_pattern='yyyy-mm-dd')
    end_cal.grid(row=1, column=1, sticky="ew")

    buyer_combo = None
    seller_combo = None

    if with_buyer:
        ttk.Label(frame, text="Выкупщик").grid(row=2, column=0, sticky="w")
        buyer_combo = ttk.Combobox(frame, values=BUYERS)
        buyer_combo.grid(row=2, column=1, sticky="ew")

    if with_seller:
        ttk.Label(frame, text="Продавец").grid(row=3, column=0, sticky="w")
        seller_combo = ttk.Combobox(frame, values=["Заргарян А.", "Язовских С.", "Кириллов А.", "Туник Д."])
        seller_combo.grid(row=3, column=1, sticky="ew")

    def handle_callback():
        callback(start_cal, end_cal, buyer_combo, seller_combo)

    ttk.Button(frame, text="Сформировать", command=handle_callback).grid(
        row=5, column=0, columnspan=2, pady=10
    )

    frame.grid_columnconfigure(1, weight=1)


# --- Вспомогательная функция сортировки ---
sort_state = {}  # Хранит состояние сортировки: {"column": "asc" или "desc"}

def sort_column(tree, full_data, column_name, all_columns):
    global sort_state

    # Убираем стрелки у всех заголовков
    for col in tree["columns"]:
        tree.heading(col, text=col.split(" ")[0])

    # Переключаем направление сортировки
    current_state = sort_state.get(column_name, None)
    if current_state == "asc":
        direction = "desc"
        arrow = " ↓"
    else:
        direction = "asc"
        arrow = " ↑"

    sort_state[column_name] = direction

    # Меняем текст заголовка
    tree.heading(column_name, text=f"{column_name}{arrow}")

    # Сортируем данные
    idx = list(all_columns).index(column_name)
    try:
        sorted_data = sorted(full_data, key=lambda x: x[idx] if x[idx] is not None else '', reverse=(direction == "desc"))
    except IndexError:
        return

    # Очищаем дерево
    for row in tree.get_children():
        tree.delete(row)

    # Вставляем отсортированные данные
    for row in sorted_data:
        tree.insert("", "end", values=row)